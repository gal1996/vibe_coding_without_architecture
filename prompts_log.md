# プロンプト記録ログ

## 概要
このファイルは、Vibe-Coding実験（グループ A: No-Arch）で投げられたすべてのプロンプトを時系列で記録します。

## 記録フォーマット
各プロンプトは以下の形式で記録されます：
- **タスクID**: TASK_XXX
- **日時**: YYYY-MM-DD HH:MM:SS
- **プロンプト内容**: 実際のプロンプトテキスト
- **開始時刻**: 作業開始時刻
- **完了時刻**: 作業完了時刻
- **実行時間**: T_exec（分）

---

## プロンプト履歴

### TASK_000: 実験環境準備
- **日時**: 2025-11-16 (初期セットアップ)
- **プロンプト内容**: 「依頼の目的：Vibe-Codingの有効性検証プロジェクト（実験記録準備）」
- **開始時刻**: -
- **完了時刻**: -
- **実行時間**: -
- **備考**: 実験記録ファイルの準備

---

---
Task_ID: TASK_001
Timestamp: 2025-11-16 12:37:06
---
# プロジェクト名: ECサイトバックエンドAPI実装

## 1. 概要
ユーザー、商品、および注文を管理するバックエンドAPIシステムを実装する。

## 2. エンティティ仕様
以下のデータ構造を定義し、システム内で使用する。

| エンティティ | 必須フィールド |
| :--- | :--- |
| **Product** (商品) | ID, 名前, 価格 (整数), 在庫数 (整数, 0以上), カテゴリ (文字列) |
| **User** (ユーザー) | ID, ユーザー名 (ユニーク), 認証情報（例：パスワードハッシュ）, 管理者フラグ (boolean) |
| **Order** (注文) | ID, ユーザーID, 注文明細 (商品IDと数量のリスト), 合計金額, ステータス |

## 3. 機能要件 (API)
以下の主要な機能を実現するためのAPIを実装すること。

1.  **商品管理:** 商品の作成、一覧表示、詳細表示の機能。
2.  **ユーザー管理:** ユーザーの登録、認証（ログイン）の機能。
3.  **注文処理:** ユーザーが商品を確定注文する機能。

## 4. ビジネスロジックと制約
特に以下の重要な制約とロジックを厳守すること。

1.  **アトミックな注文処理:** 注文の確定時、要求された商品について以下の処理を**同時に**実行すること。
    * 在庫チェック: 在庫が不足している場合は注文を拒否する。
    * 在庫削減: 注文が成功した場合、該当商品の在庫数を注文数分だけ正確に減少させること。
2.  **商品一覧のフィルタリング:** 商品一覧を取得する際、カテゴリ名に基づいてフィルタリングできること。
3.  **管理者認可:** 新規商品を作成する機能は、**管理者ユーザー**のみが実行できること。

---

## 5. 実験タスク

### タスク A: 最小実装
上記の仕様を満たすコードを、**最も迅速かつ少ないファイル数**で実装し、その結果のファイル構成とコードを提示してください。

### タスク B: アーキテクチャ分離実装
上記の仕様を満たすコードを、**クリーンアーキテクチャ**の原則に基づき、厳密なレイヤー分離を適用して実装し、その結果のファイル構成とコードを提示してください。
---

### TASK_MT1: 消費税と送料ロジックの実装
- **タスクID**: TASK_MT1
- **日時**: 2025-11-16 18:45:00
- **プロンプト内容**:
```
# MT-1 機能追加タスク：消費税と送料ロジックの実装

このタスクは、既存のECサイトバックエンドAPIに対する仕様変更（保守性検証）です。あなたは、初期実装されたコードベースに以下のロジックを追加する必要があります。

## 1. 共通の仕様変更内容

すべての注文処理に対し、以下のビジネスロジックを追加してください。

1.  **消費税 (10%) の適用:**
    * 注文の合計金額（`total_amount`）を計算する際、商品価格の合計（税抜）に一律で **10% の消費税**を加算すること。
2.  **送料無料条件の追加:**
    * 注文の合計金額（税抜）が **5,000円**以上の場合は送料を**無料**とし、5,000円未満の場合は一律 **500円**の送料を加算すること。
3.  **エンティティの更新:**
    * `Order` エンティティには、最終的な合計金額（送料・税込）を保持する既存のフィールドに加え、新たに **`shipping_fee`（送料額）**フィールドを追加すること。
```
- **開始時刻**: 18:45:00
- **完了時刻**: 19:00:00
- **実行時間**: 15分

---

### TASK_MT3: 外部決済ゲートウェイ連携
- **タスクID**: TASK_MT3
- **日時**: 2026-01-04 11:57:34
- **プロンプト内容**:
```
🚀 MT-3 仕様書：外部決済ゲートウェイの連携
1. 概要
現在の注文フローを拡張し、外部の決済サービスとの連携機能を追加する。決済が承認された場合のみ、在庫の減算および注文の確定を行うように変更すること。

2. 追加機能：決済確認ステップ
注文確定処理（POST /orders）のプロセス内に、以下のロジックを組み込むこと。

外部決済呼び出し（シミュレーション）:
- 注文の「最終合計金額」をパラメータとして受け取り、決済の成否を返す外部通信処理をシミュレートすること。
- 実装: 外部APIの実体はないため、ランダム（例：90%で成功）または特定のロジックで Success / Failure を返すダミーの関数またはクラスを内部に用意して呼び出す。

ステータス制御:
- 決済成功時: 在庫を減算し、注文ステータスを Completed（完了）として保存する。
- 決済失敗時: 在庫は減らさず、注文ステータスを PaymentFailed（決済失敗）等で保存し、ユーザーには適切なエラーレスポンスを返すこと。

3. ビジネスルールと制約
- 実行順序の厳守: 在庫を減らした後に決済が失敗して、在庫が戻らないといった不整合を避けるため、適切な順序（またはトランザクション管理）で実装すること。
- 拡張性: 将来的に本物の決済プロバイダ（Stripe等）へ差し替えられるよう、決済ロジックの独立性を考慮すること。
```
- **開始時刻**: 11:57:34
- **完了時刻**: 12:11:47
- **実行時間**: 14分
- **備考**:
  - 決済機能の実装自体は一発で正常動作
  - 既存実装の2つのバグを発見・修正：
    1. `generateToken()`関数でトークンが重複する問題（タイムスタンプの精度不足）
    2. `TestMainHandler`テストケースの期待値の誤り（404 vs 405）
  - これらのバグは過去の実装（TASK_001）に起因するもの

---

### TASK_MT4: 複数拠点での在庫管理（マルチワイヤハウス）への移行
- **タスクID**: TASK_MT4
- **日時**: 2026-01-04 13:42:44
- **プロンプト内容**:
```
🚀 MT-4 仕様書：複数拠点での在庫管理（マルチワイヤハウス）への移行
1. 概要
事業拡大に伴い、これまで商品ごとに1つだった在庫数（単一の数値）を、複数の拠点（倉庫）ごとに切り分けて管理するようにシステムを拡張します。

2. データモデルの変更
在庫の持ち方を以下のように変更してください。

Productエンティティの変更:
- 既存の stock_quantity フィールドを削除してください。

Warehouse（倉庫）エンティティの導入:
- フィールド: id (UUID/Int), name (文字列)

Stock（在庫明細）の導入:
- 商品と倉庫を紐づけ、拠点ごとの quantity（在庫数）を保持します。
- 1つの商品は複数の倉庫に在庫を持つことができます。

3. 機能要件の変更
3.1. 商品取得 API (GET /products/{id})
- レスポンスに、各倉庫ごとの在庫内訳（倉庫名、在庫数）を含めるように拡張してください。
- 全倉庫の合計在庫数も併せて表示してください。

3.2. 注文確定 API (POST /orders)
在庫の引き当てロジックを以下のように変更してください。
- 在庫確認: 対象商品の「全倉庫の合計在庫数」が注文数以上あるかを確認します。
- 引き当てロジック: 合計在庫が十分な場合、在庫が存在する倉庫から順に注文数を差し引いてください。
  例：注文数5に対し、倉庫Aに3個、倉庫Bに10個ある場合、倉庫Aから3個、倉庫Bから2個差し引く。
- 不整合の防止: 合計在庫が不足している場合は、これまで通り注文を拒否（エラー）としてください。

4. 制約および注意点
- 既存機能の継承: 以前に実装した「消費税・送料計算ロジック」および「外部決済ゲートウェイ連携（決済失敗時のロールバック）」が正しく動作し続けるようにしてください。
- 初期データ: 動作確認ができるよう、あらかじめ2〜3の倉庫データと、それらに紐づく初期在庫データを生成（Seed）しておいてください。
```
- **開始時刻**: 13:42:44
- **完了時刻**: 14:18:41
- **実行時間**: 36分

---

### TASK_MT5: 高度なクーポンシステムと適用ルールの導入
- **タスクID**: TASK_MT5
- **日時**: 2026-01-04 15:07:26
- **プロンプト内容**:
```
🚀 MT-5 仕様書：高度なクーポンシステムと適用ルールの導入
1. 概要
販促キャンペーンの実施に伴い、注文時に「クーポンコード」を適用して割引を受けられる機能を追加します。複数の割引・加算要素があるため、計算順序を厳密に実装してください。

2. クーポンの仕様
システムに以下の2種類のクーポン概念を導入してください。
- 定額割引クーポン (Fixed Amount): 注文合計額から一律で指定金額（例：1,000円）を差し引く。
- 定率割引クーポン (Percentage): 注文合計額に対して指定の割合（例：10%）を差し引く。

共通制約:
- 1回の注文につき、クーポンは最大1つまで適用可能。
- 割引適用後の合計金額が0円を下回ることはない（最低0円）。
- 有効なクーポンコードのマスターデータ（例：SAVE10, FLAT1000など）を事前に用意しておくこと。

3. 改訂版：支払い金額の算出アルゴリズム
以下の順序に従って、最終的な支払金額（total_amount）を計算するようにロジックを更新してください。
1. 商品小計の算出: （各商品の単価 × 数量）の合計。
2. 消費税の加算: 商品小計に対し、一律10%を加算。
3. 送料の確定: 消費税加算後の金額に基づき、既存の送料ルール（5,000円以上無料、未満は500円）を適用。
4. クーポン割引の適用: ※重要: クーポン割引は「商品代金 ＋ 消費税」の金額に対して計算・適用し、「送料」は割引の対象外とすること。
5. 最終金額の確定: （商品代金 ＋ 消費税 − クーポン割引額） ＋ 送料 ＝ 最終支払額。

4. APIの変更
注文確定 API (POST /orders):
- リクエストボディにオプション項目として coupon_code (文字列) を追加。
- レスポンスおよび保存される注文データに、discount_amount（実際に割引された額）と applied_coupon（適用されたコード）を含めること。

バリデーション:
- 存在しない、または無効なクーポンコードが送られた場合は、エラーを返して注文を中断すること。

5. 注意事項
- 既存の「マルチ拠点在庫管理（MT-4）」および「決済ゲートウェイ連携（MT-3）」のフローと完全に統合してください。
- 決済失敗によるロールバック時には、在庫だけでなくクーポン適用状態等に矛盾が生じないようにすること。
```
- **開始時刻**: 15:07:26
- **完了時刻**: 15:19:45
- **実行時間**: 12分

---

### TASK_MT6: 管理者向け販売分析レポートAPIの追加
- **タスクID**: TASK_MT6
- **日時**: 2026-01-05 15:24:46
- **プロンプト内容**:
```
🚀 MT-6 仕様書：管理者向け販売分析レポート API の追加
1. 概要
経営判断を迅速化するため、管理者が現在の販売状況や在庫状況をリアルタイムで把握できる「統計レポート API」を新規に実装してください。

2. 新規エンドポイント
エンドポイント: GET /admin/reports/sales

認可: **管理者ユーザー（is_admin=True）**のみがアクセス可能であること。

3. レポートの集計内容
以下の4つの指標を計算し、JSON形式で返却すること。

販売サマリー:

累計売上額（total_revenue）: ステータスが Completed の全注文の最終支払額の合計。

累計注文数（total_orders）: 同上の注文総数。

人気商品ランキング:

販売数量（Quantity）が多い順に、トップ3の商品名と販売合計数をリスト形式で提示すること。

倉庫別在庫サマリー:

各倉庫（Warehouse）ごとに、現在保管されている全商品の在庫合計数を算出すること。

プロモーション効果分析:

クーポン利用率（coupon_usage_rate）: 全注文のうち、クーポンが適用された注文が占める割合（％）を算出すること。

4. 技術的な制約・考慮事項
パフォーマンスへの配慮: 集計ロジックが既存の注文処理（POST /orders）や商品取得（GET /products）のレスポンス速度に悪影響を与えないように実装すること。

データの正確性: 注文ステータスが PaymentFailed（決済失敗）のものは、売上やランキングの集計から除外すること。

コードの整理: 分析用のクエリロジックが肥大化する場合、既存のCRUDロジックと混ざらないよう、適切に役割（責務）を分離して実装すること。
```
- **開始時刻**: 15:24:46
- **完了時刻**: 15:36:01
- **実行時間**: 11分
- **備考**: テスト実装時にテストデータの独立性を保つためのバグを1件修正

---

### TASK_MT7: お気に入り機能とパーソナライズ情報の追加
- **タスクID**: TASK_MT7
- **日時**: 2026-01-05 22:33:59
- **プロンプト内容**:
```
🚀 MT-7 仕様書：お気に入り機能とパーソナライズ情報の追加
1. 概要
ユーザーが商品を「お気に入り」として保存できる機能を追加し、商品閲覧時に「自分がその商品をお気に入り登録しているか」がわかるようにシステムを拡張します。また、マイページでおすすめ商品を表示できるようにします。

2. 新規エンティティ・データ構造
Wishlist (お気に入り):

ユーザーIDと商品IDのペアを保持する。

同一ユーザーが同じ商品を重複して登録することはできない。

3. 機能要件
3.1. お気に入り操作 API
登録 (POST /wishlist/{product_id}): ログイン中のユーザーがお気に入りに商品を追加する。

削除 (DELETE /wishlist/{product_id}): お気に入りから削除する。

3.2. 商品一覧・詳細 API の拡張 (GET /products)
商品情報のレスポンスに、is_favorite (boolean) フィールドを追加してください。

認証済みの場合: ログイン中のユーザーがその商品をお気に入りに登録していれば true、そうでなければ false を返す。

未認証の場合: 常に false を返す。

3.3. おすすめ商品取得 API (GET /users/me/recommendations)
ログイン中のユーザー向けに、以下のロジックで「おすすめ」を最大3件返す。

ロジック: ユーザーが現在お気に入りに登録している商品と同じ**「カテゴリ」**に属する商品の中から、まだお気に入りに登録していないものを優先的に抽出する。

4. 技術的な制約・考慮事項
既存APIへの影響: 既存の商品取得ロジックに「ユーザー固有の状態（お気に入りかどうか）」を混ぜ込む際、キャッシュ戦略やクエリの共通性を損なわないように注意すること。

認可: お気に入り操作およびレコメンデーションの取得は、ログイン済みの本人しか実行できないようにすること。
```
- **開始時刻**: 22:33:59
- **完了時刻**: 22:55:00
- **実行時間**: 21分
- **備考**:
  - Wishlistエンティティと関連データストアの追加
  - お気に入り登録/削除APIの実装
  - 商品レスポンスにis_favoriteフィールドを追加
  - カテゴリベースのレコメンデーション機能実装
  - テスト実装時に他テストデータとの干渉問題を修正（専用カテゴリ名を使用）

---

### TASK_MT8: ポイントプログラムおよび会員ランク制度の導入
- **タスクID**: TASK_MT8
- **日時**: 2026-01-25
- **開始時刻**: 00:08:00
- **プロンプト内容**:
```
MT-8 追加機能仕様書：ポイントプログラムおよび会員ランク制度の導入
1. 概要
ユーザーのロイヤリティ向上を目的に、購入金額に応じた「ポイント還元・利用」機能、および累計購入金額に基づいた「会員ランク制度」を導入します。

2. 会員ランク (Membership Rank) の定義
ユーザーのこれまでの累計購入金額（ステータスが Completed の注文合計額の総計）に基づき、以下のランクと特典を適用してください。

会員ランクと昇格条件
一般 (Normal)
- 昇格条件：累計購入額 0円 〜 49,999円
- 特典：なし（標準価格）

シルバー (Silver)
- 昇格条件：累計購入額 50,000円 〜 99,999円
- 特典：商品価格（税込）から一律 3% OFF

ゴールド (Gold)
- 昇格条件：累計購入額 100,000円 以上
- 特典：商品価格（税込）から一律 5% OFF ＋ 常に送料無料

ランク更新のルール
注文ステータスが Completed になった直後に、当該ユーザーの累計購入額を再計算し、即座にランクを更新すること。

3. ポイントシステム (Point System) の定義
ポイントの付与
注文確定時、最終支払額（税込・送料込）の 1%（小数点以下切り捨て）をポイントとして新規付与する。

ポイントの利用
注文時、保有ポイントを 1ポイント = 1円 として利用可能にする。
注文API（POST /orders）のリクエストボディで利用ポイント数（use_points）を指定できること。

4. 支払い金額の算出アルゴリズム（重要）
既存の計算フローを以下の順序に更新してください。
1. 商品小計の算出: ユーザーの現在の会員ランクに応じた割引（3% または 5%）を適用した後の価格で算出する。
2. 消費税の加算: ランク割引適用後の小計に対し 10% を加算する。
3. 送料の確定:
   - ゴールド会員の場合：常に 0円。
   - それ以外の場合：消費税加算後の金額が 5,000円以上なら 0円、5,000円未満なら 500円。
4. クーポン割引の適用: 割引対象は「商品代金 ＋ 消費税」のみとし、送料は割引対象外とする。
5. ポイント利用: 最後にポイント利用分を差し引く。注意：最終金額が 0円を下回る場合は 0円とする。

5. APIの変更要件
注文確定 API (POST /orders)
- リクエスト: use_points (整数) を追加。
- レスポンス: earned_points（今回獲得したポイント）、used_points（今回利用したポイント）、new_total_points（更新後の保有ポイント）、current_rank（更新後の会員ランク）

ユーザー情報 API (GET /users/me)
レスポンスに以下のフィールドを追加：
- rank: 現在のランク名
- total_spent_amount: 累計購入金額
- current_points: 現在の保有ポイント残高

6. 実装上の制約事項
- トランザクション整合性: 外部決済（MT-3）が失敗した場合は、ポイントの消費を取り消し、ランク判定用の累計額にも今回の注文分を含めないこと。
- データ不整合の防止: 保有ポイントを超える use_points が指定された場合はエラーを返却すること。
```
- **完了時刻**: 00:27:00
- **実行時間**: 19分

---

<!-- 以下、新しいプロンプトが投げられるたびに追記されます -->